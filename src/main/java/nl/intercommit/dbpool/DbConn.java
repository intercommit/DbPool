/*  Copyright 2011 InterCommIT b.v.
*
*  This file is part of the "DbPool" project hosted on https://github.com/intercommit/DbPool
*
*  DbPool is free software: you can redistribute it and/or modify
*  it under the terms of the GNU Lesser General Public License as published by
*  the Free Software Foundation, either version 3 of the License, or
*  any later version.
*
*  DbPool is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU Lesser General Public License for more details.
*
*  You should have received a copy of the GNU Lesser General Public License
*  along with DbPool.  If not, see <http://www.gnu.org/licenses/>.
*
*/
package nl.intercommit.dbpool;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A helper class that makes it easy to fire a query, get results and cleanup.
 * A typical usage scenario is the following (see also the test-classes): <pre>
 * DbConn c = new DbConn(myPool);
 * try {
 * 	c.setNQuery("select id from t where name like @name");
 * 	c.nps.setString("name", "searchValue");
 * 	c.rs = c.nps.executeQuery();
 * 	... process results ...
 * } catch (Exception e) {
 *   ... handle error ...
 * } finally { c.close(); }
 * </pre>
 * @author frederikw
 *
 */
public class DbConn {

	/** The database pool from the contructor. */
	public DbPool pool;
	/** An actual database connection, set when getConnection() is called. */
	public Connection conn;
	/** A prepared statement, set when setQuery() is called. */
	public PreparedStatement ps;
	/** A named prepared statement, set when setNQuery() is called. */
	public NamedParameterStatement nps;
	/** A resultset, can be used as placeholder for the query results of one query. */
	public ResultSet rs;
	
	/** Sets {@link #pool} to given pool. */
	public DbConn(final DbPool pool) {
		super();
		this.pool = pool;
	}
	
	/** Sets {@link #conn} to given open database connection. */
	public DbConn(final Connection c) {
		super();
		this.conn = c;
	}

	/** Closes {@link #rs}, {@link #ps} and {@link #nps} (if not null), but does not release or close the database connection.
	 * Sets rs, ps and nps to null after closing. Uses the {@link #closeLogger} to log errors as warnings.
	 */
	public void closeQuery() {
		if (rs != null) { close(rs); rs = null; }
		if (ps != null) { close(ps); ps = null; }
		if (nps != null) { close(nps); nps = null; }
	}
	
	/** Acquires a connection from the pool, but only when {@link #conn} is null. */
	public Connection getConnection() throws SQLException {
		
		if (conn == null) {
			conn = pool.acquire();
		}
		return conn;
	}
	
	/** Calls {@link #setQuery(String, int)} with autoGeneratedKeys ignored. */
	public PreparedStatement setQuery(final String query) throws SQLException {
		return setQuery(query, -1);
	}
	
	/** 
	 * Sets {@link #ps} with the given query. Gets a connection if {@link #conn} is null. 
	 * Calls {@link #closeQuery()} when {@link #ps} or {@link #nps} is not null.
	 * <br>If autoGeneratedKeys is -1, it is ignored, else if autoGeneratedKeys
	 * equals java.sql.Statement.RETURN_GENERATED_KEYS for example, 
	 * generated keys are returned in the resultset
	 * (how generated keys are returned depends on the type of database,
	 * e.g. mysql will return a column with the name "GENERATED_KEY").
	 */
	public PreparedStatement setQuery(final String query, final int autoGeneratedKeys) throws SQLException {
		getConnection();
		if (ps != null || nps != null) closeQuery();
		if (autoGeneratedKeys > -1)
			ps = conn.prepareStatement(query, autoGeneratedKeys);
		else 
			ps = conn.prepareStatement(query);
		return ps;
	}

	/** Calls {@link #setNQuery(String, int)} with autoGeneratedKeys ignored. */
	public NamedParameterStatement setNQuery(final String query) throws SQLException {
		return setNQuery(query, -1);
	}
	/** 
	 * Same as {@link #setQuery(String, int)}, but this time for a named query (sets {@link #nps} instead of {@link #ps}). 
	 */
	public NamedParameterStatement setNQuery(final String query, final int autoGeneratedKeys) throws SQLException {
		getConnection();
		if (ps != null || nps != null) closeQuery();
		if (autoGeneratedKeys > -1) 
			nps = new NamedParameterStatement(conn, query, autoGeneratedKeys);
		else 
			nps = new NamedParameterStatement(conn, query);
		return nps;
	}
	
	/** Closes all open resources ({@link #ps}, {@link #nps} and {@link #rs}) by calling {@link #closeQuery()} 
	 * and releases the database connection (or, if there is no pool, closes the connection). 
	 * {@link #ps}, {@link #nps}, {@link #rs} and {@link #conn} are set  to null so that subsequent calls to this method have no effect. 
	 * <br>This is required in for example Tomcat, see for example the "Random Connection Closed Exceptions" problem
	 * described at
	 * http://yzb.hit.edu.cn/docs/printer/jndi-datasource-examples-howto.html#Common%20Problems
	 */
	public void close() {
		closeQuery();
		if (conn != null) {
			if (pool == null) {
				try { conn.close(); } catch (SQLException sqle) {
					closeLogger.warn("Failed to close a database connection: " + sqle);
				}
			} else {
				pool.release(conn);
			}
			conn = null;
		}
	}
	
	/** Logger used to log a warning when a close method encounters an error. */ 
	public static Logger closeLogger = LoggerFactory.getLogger(DbConn.class);
	
	/** Closes s (checks for null-value), logs any error as warning using closeLogger. */
	public static void close(final Statement s) {
		try {
			if (s != null) s.close();
		} catch (SQLException se) {
			closeLogger.warn("Failed to close statement: " + s);
		}
	}

	/** Closes s (checks for null-value), logs any error as warning using closeLogger. */
	public static void close(final NamedParameterStatement s) {
		try {
			if (s != null) s.close();
		} catch (SQLException se) {
			closeLogger.warn("Failed to close named statement: " + s);
		}
	}
	
	/** Closes rs (checks for null-value), logs any error as warning using closeLogger. */
	public static void close(final ResultSet rs) {
		try {
			if (rs != null) rs.close();
		} catch (SQLException se) {
			closeLogger.warn("Failed to close result set: " + rs);
		}
	}
	
	/**
	 * Utility method for constructing a prepared statement using the 'in' keyword.
	 * <br>Copied from http://stackoverflow.com/questions/178479/preparedstatement-in-clause-alternatives.
	 * <br>Usage:
	 * <br> String SQL_FIND = "SELECT id, name, value FROM data WHERE id IN (%s)" 
	 * <br> String sql = String.format(SQL_FIND, preparePlaceHolders(ids.size()));
	 * <br> statement = connection.prepareStatement(sql);
	 * <br> setValues(statement, ids.toArray());
	 * <br> resultSet = statement.executeQuery();
	 */
	public static String preparePlaceHolders(final int length) {
	    
		StringBuilder sb = new StringBuilder();
	    for (int i = 0; i < length;) {
	        sb.append("?");
	        if (++i < length) {
	            sb.append(",");
	        }
	    }
	    return sb.toString();
	}

	/** 
	 * See comments on {@link #preparePlaceHolders(int)}
	 */
	public static void setValues(final PreparedStatement preparedStatement, final Object... values) throws SQLException {
	    for (int i = 0; i < values.length; i++) {
	        preparedStatement.setObject(i + 1, values[i]);
	    }
	}

}
